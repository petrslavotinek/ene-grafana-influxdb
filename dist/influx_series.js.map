{"version":3,"sources":["../src/influx_series.js"],"names":["_","TableModel","InfluxSeries","options","series","alias","annotation","output","i","j","length","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","regex","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","includeMeasurementColumn","table","seriesIndex","type","keys","reordered","hasOwnProperty","rows"],"mappings":"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","file":"influx_series.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\n\nexport default class InfluxSeries {\n  series;\n  alias;\n  annotation;\n\n  constructor(options) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n  }\n\n  getTimeSeries() {\n    var output = [];\n    var i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      var columns = series.columns.length;\n      var tags = _.map(series.tags, function(value, key) {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        var seriesName = series.name;\n        var columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        var datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series, index) {\n    var regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    var segments = series.name.split('.');\n\n    return this.alias.replace(regex, function(match, g1, g2) {\n      var group = g1 || g2;\n      var segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      var tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    var list = [];\n\n    _.each(this.series, series => {\n      var titleCol = null;\n      var timeCol = null;\n      var tagsCol = [];\n      var textCol = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (!titleCol) {\n          titleCol = index;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n      });\n\n      _.each(series.values, value => {\n        var data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter(function(t) {\n                return value[t];\n              })\n              .map(function(t) {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(includeMeasurementColumn) {\n    var table = new TableModel();\n    var i, j;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series, seriesIndex) => {\n      if (seriesIndex === 0) {\n        table.columns.push({ text: 'Time', type: 'time' });\n        if (includeMeasurementColumn) {\n          table.columns.push({text: 'Measurement'});\n        }\n        _.each(_.keys(series.tags), function(key) {\n          table.columns.push({ text: key });\n        });\n        for (j = 1; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          var values = series.values[i];\n          var reordered = [values[0]];\n          if (includeMeasurementColumn) {\n            reordered.push(series.name);\n          }\n          if (series.tags) {\n            for (var key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n"]}